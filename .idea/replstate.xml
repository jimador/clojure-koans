<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1461699917546">{:repl-history {:ide [], :local [&quot;(= 1 (count [42]))&quot; &quot;(= [1] (vec '(1)))&quot; &quot;(= [nil nil] (vector nil nil))&quot; &quot;(= [1 2] (vec '(1 2)))&quot; &quot;(= [111 222 333] (conj [111 222] 333))&quot; &quot;(= :peanut (first [:peanut :butter :and :jelly]))&quot; &quot;(= :jelly (last [:peanut :butter :and :jelly]))&quot; &quot;(= :jelly (nth [:peanut :butter :and :jelly] 3))&quot; &quot;(= [:butter :and] (subvec [:peanut :butter :and :jelly] 1 3))&quot; &quot;(= (list 1 2 3) (vector 1 2 3))&quot; &quot;(= #{3} (set 3))&quot; &quot;(= #{3} (set '(3)))&quot; &quot;(= 3 (count #{1 2 3}))&quot; &quot;(= #{1 2 3 4 5} (set '(1 1 2 2 3 3 4 4 5 5)))&quot; &quot;(= #{1 4 5} (set/union #{1 2 3 4} #{2 3 5}))&quot; &quot;(= #{1 2 3 4 5} (set/union #{1 2 3 4} #{2 3 5}))&quot; &quot;(= #{2 3} (set/intersection #{1 2 3 4} #{2 3 5}))&quot; &quot;(= #{1 4} (set/difference #{1 2 3 4 5} #{2 3 5}))&quot; &quot;(= (list \&quot;PyeongChang\&quot; \&quot;Sochi\&quot; \&quot;Vancouver\&quot;)\n   (sort (vals {2010 \&quot;Vancouver\&quot; 2014 \&quot;Sochi\&quot; 2018 \&quot;PyeongChang\&quot;})))&quot; &quot;(= (list 2010 2014 2018)\n   (sort (keys { 2014 \&quot;Sochi\&quot; 2018 \&quot;PyeongChang\&quot; 2010 \&quot;Vancouver\&quot;})))&quot; &quot;(= {1 \&quot;January\&quot;} (dissoc {1 \&quot;January\&quot; 2 \&quot;February\&quot;} 2))&quot; &quot;(= {1 \&quot;January\&quot; 2 \&quot;February\&quot;} (assoc {1 \&quot;January\&quot;} 2 \&quot;February\&quot;))&quot; &quot;(= false (contains? {:a nil :b nil} :c))&quot; &quot;(= true (contains? {:a nil :b nil} :b))&quot; &quot;(= :key-not-found (get {:a 1 :b 2} :c :key-not-found))&quot; &quot;(= nil (get {:a 1 :b 2} :c))&quot; &quot;(= \&quot;Sochi\&quot; ({2010 \&quot;Vancouver\&quot; 2014 \&quot;Sochi\&quot; 2018 \&quot;PyeongChang\&quot;} 2014))&quot; &quot;(= 1 (:a {:a 1 :b 2}))&quot; &quot;(= 1 ({:a 1 :b 2} :a))&quot; &quot;(= 2 (get {:a 1 :b 2} :b))&quot; &quot;(= 2 (count {:a 1 :b 2}))&quot; &quot;(= {:a 1} (hash-map :a 1))&quot; &quot;(= 25 (5 square))&quot; &quot;(= 25 (fn [f] (f 5) square))&quot; &quot;(= 81 (square 9))&quot; &quot;(= 20 (multiply-by-ten 2))&quot; &quot;(= 10 ((fn [n] (* 5 n)) 2))&quot; &quot;(= 1 (#(* 15 %) 4))&quot; &quot;(= 3 (#(* 15 %) 4))&quot; &quot;(#(* 15 %) 4)&quot; &quot;(= 60 (#(* 15 %) 4))&quot; &quot;(#(+ %1 %2 %3) 4 5 6)&quot; &quot;(#(* 15 %2) 1 2)&quot; &quot;(((fn [] #(+ %1 %2))) 4 5)&quot; &quot;(= 9 (((fn [] #(+ %1 %2))) 4 5))&quot; &quot;((fn [f] (f 4 5))\n        #(*))&quot; &quot;((fn [f] (f 4 5))\n        #(* %1 %2))&quot; &quot;(fn [f 5]\n        (fn [n] (* n n)))&quot; &quot;(fn [f] (f 5)\n        (fn [n] (* n n)))&quot; &quot;((fn [f] (f 5))\n        (fn [n] (* n n)))&quot; &quot;((fn [f] (f 5)) square)&quot; &quot;(= :b (if (false? (= 4 5))\n        :a\n        :b))&quot; &quot;(= :a (if (false? (= 4 5))\n        :a\n        :b))&quot; &quot;(= [] (if (&gt; 4 3)\n        []))&quot; &quot;(= nil (if (nil? 0)\n        [:a :b :c]))&quot; &quot;(= :glory (if (not (empty? ()))\n            :doom\n            :glory))&quot; &quot;(let [x 5]\n  (= :your-road (cond (= x 1) :road-not-taken\n                      (= x 2) :another-road-not-taken\n                      :else :your-road)))&quot; &quot;(= 'doom (if-not (zero? 0)\n           'doom\n           'more-doom))&quot; &quot;(= 'doom (if-not (zero? 1)\n           'doom\n           'more-doom))&quot; &quot;(= \&quot;pretty fast\&quot;\n   (explain-exercise-velocity :bycicling))&quot; &quot;(= \&quot;pretty fast\&quot;\n   (explain-exercise-velocity :bicycling))&quot; &quot;(= \&quot;is that even exercise?\&quot;\n   (explain-exercise-velocity :watching-tv))&quot; &quot;(= [4 8 9] (map (fn [x] (* 4 x)) [1 2 3]))&quot; &quot;(= [1 4 9 16 25] (map (fn [x] * x x) [1 2 3 4 5]))&quot; &quot;(= [1 4 9 16 25] (map (fn [x] (* x x)) [1 2 3 4 5]))&quot; &quot;(= [false false true false false] (map nil? [:a :b nil :c :d]))&quot; &quot;(= '() (filter (fn [x] false) '(:anything :goes :here)))&quot; &quot;(= '(:anything :goes :here) (filter (fn [x] true) '(:anything :goes :here)))&quot; &quot;(= [10 20 30] (filter (fn [x] (&lt; x 40)) [10 20 30 40 50 60 70 80]))&quot; &quot;(= [10 20 30] (map (fn [x] (* x 10)) (filter (fn [x] (&lt; x 4)) [1 2 3 4 5 6 7 8])))&quot; &quot;(reduce (fn [a b] (* a b)) [1 2 3 4])&quot; &quot;(= 24 (reduce (fn [a b] (* a b)) [1 2 3 4]))&quot; &quot;(= 2400 (reduce (fn [a b] (* a b)) 100 [1 2 3 4]))&quot; &quot;(= \&quot;longest\&quot; (reduce (fn [a b]\n                       (if (&lt; a b) b a))\n                     [\&quot;which\&quot; \&quot;word\&quot; \&quot;is\&quot; \&quot;longest\&quot;]))&quot; &quot;(= \&quot;longest\&quot; (reduce (fn [a b]\n                       (if (&lt; (count a) (count b)) b a))\n                     [\&quot;which\&quot; \&quot;word\&quot; \&quot;is\&quot; \&quot;longest\&quot;]))&quot; &quot;(= \&quot;Hello World!\&quot; (hello))&quot; &quot;(= \&quot;Hello, you silly world.\&quot; (hello \&quot;world\&quot;))&quot; &quot;(= \&quot;Hello to this group: Peter, Paul, Mary!\&quot;\n     (hello \&quot;Peter\&quot; \&quot;Paul\&quot; \&quot;Mary\&quot;))&quot; &quot;(= \&quot;Bambi eats veggies.\&quot;\n     (diet {:species \&quot;deer\&quot; :name \&quot;Bambi\&quot; :age 1 :eater :herbivore}))&quot; &quot;(= \&quot;Thumper eats veggies.\&quot;\n     (diet {:species \&quot;rabbit\&quot; :name \&quot;Thumper\&quot; :age 1 :eater :herbivore}))&quot; &quot;(= \&quot;Simba eats animals.\&quot;\n     (diet {:species \&quot;lion\&quot; :name \&quot;Simba\&quot; :age 1 :eater :carnivore}))&quot; &quot;(= \&quot;I don't know what Rich Hickey eats.\&quot;\n     (diet {:name \&quot;Rich Hickey\&quot;}))&quot; &quot;(= [1 2 3 4] (range 1 5))&quot; &quot;(= [0 1 2 3 4] (range 5))&quot; &quot;(= [0 1 2 3 4 5 6 7 8 9]\n   (take 10 (range 100)))&quot; &quot;(= [95 96 97 98 99]\n   (drop 95 (range 100)))&quot; &quot;(= 19 (take 20 (iterate inc 0)))&quot; &quot;(= 20 (take 20 (iterate inc 0)))&quot; &quot;(= (range 20) (take 20 (iterate inc 0)))&quot; &quot;(= [:a :a :a :a :a :a :a :a :a :a]\n   (repeat 10 :a))&quot; &quot;(= (repeat 100 :hello)\n   (take 100 (iterate 100 :hello)))&quot; &quot;(= (repeat 100 :hello)\n   (take 100 (iterate inc :hello)))&quot; &quot;(= (repeat 100 :hello)\n   (take 100 (iterate identity :hello)))&quot; &quot;(for [x (range 6)]\n     x)&quot; &quot;(iterate inc 6)&quot; &quot;range 6&quot; &quot;(range 6)&quot; &quot;(take 6 (iterate inc))&quot; &quot;(take 6 (iterate inc 0))&quot; &quot;(take 20 (iterate inc 0))&quot; &quot;(= (take 6 (iterate inc 0))\n   (for [x (range 6)]\n     x))&quot;], :remote []}}</component>
</project>